class: middle, center, inverse

# How to start

#### Add the target to LLVM / Clang / LLD

##### Unlike GCC, you don't need to build a cross-compiler

##### Describe your target and the subtargets

---

class: middle, center, inverse

# Registers

```tablegen
def R0 : J2Reg<0, "r0">, DwarfRegNum<[ 0 ]>;

[...]

def R15 : J2Reg<15, "r15", [ "sp" ]>, DwarfRegNum<[ 15 ]>;
```

Register classes

```tablegen
def GPR : RegisterClass<"J2", [ i32 ], 32, (add R0, [...], R15)>;
```

Reserved registers

---

class: middle, center, inverse

## Tablegen

#### Why ?

--

##### Avoid duplication

--

##### Avoid C++ metaprogramming

--

##### Easily modulable

--

##### Focus on the description of the target

--

##### Performance



---

class: middle, center, inverse

# Instructions

## Instruction formats

```center
15                          0                             
----------------------------- x: opcode                   
|      |      |      |      | n : src                     
| xxxx | nnnn | mmmm | xxxx |                             
|      |      |      |      | m : dst                     
----------------------------- x: instruction-specific data
```

--

```tablegen
class FNM<bits<4> op, bits<4> data, dag outs, dag ins, string asmstr,
          list<dag> pattern> {

    bits<4> dst;
    bits<4> src;

    let Inst{15 - 12} = op;
    let Inst{11 - 8} = dst;
    let Inst{7 - 4} = src;
    let Inst{3 - 0} = data;
}
```

---

class: middle, center, inverse

## my_first_instruction

```center
add r0, r14
```

--

#### RTFM

```center
add Rm,Rn                        Rm + Rn -> Rn                    0011nnnnmmmm1100
```

---

class: middle, center, inverse

```center
add Rm,Rn                        Rm + Rn -> Rn                    0011nnnnmmmm1100
```

```tablegen
let                 ,                            ,           in {
  def ADDrr :    <   ,    , (outs         ), (ins                  ),
                  "             ",
                  [ (                                     ) ]>;
```

---

class: middle, center, inverse

```center
add Rm,Rn                        Rm + Rn -> Rn                    0011nnnnmmmm1100
```

```tablegen
let                 , Constraints = "$rnd = $rns",           in {
  def ADDrr :    <   ,    , (outs GPR:$rnd), (ins GPR:$rm, GPR:$rns),
                  "             ",
                  [ (                                     ) ]>;
```

---

class: middle, center, inverse

```center
add Rm,Rn                        Rm + Rn -> Rn                    0011nnnnmmmm1100
```

```tablegen
let                 , Constraints = "$rnd = $rns",           in {
  def ADDrr :    <   ,    , (outs GPR:$rnd), (ins GPR:$rm, GPR:$rns),
                  "add $rm, $rnd",
                  [ (                                     ) ]>;
```
---

class: middle, center, inverse

```center
add Rm,Rn                        Rm + Rn -> Rn                    0011nnnnmmmm1100
```

```tablegen
let                 , Constraints = "$rnd = $rns",           in {
  def ADDrr :    <   ,    , (outs GPR:$rnd), (ins GPR:$rm, GPR:$rns),
                  "add $rm, $rnd",
                  [ (set i32:$rnd, (add i32:$rm, i32:$rns)) ]>;
```
---

class: middle, center, inverse

```center
add Rm,Rn                        Rm + Rn -> Rn                    0011nnnnmmmm1100
```

```tablegen
let                 , Constraints = "$rnd = $rns",           in {
  def ADDrr : FNM<0x3, 0xC, (outs GPR:$rnd), (ins GPR:$rm, GPR:$rns),
                  "add $rm, $rnd",
                  [ (set i32:$rnd, (add i32:$rm, i32:$rns)) ]>;
```
---

class: middle, center, inverse

```center
add Rm,Rn                        Rm + Rn -> Rn                    0011nnnnmmmm1100
```

```tablegen
let isCommutable = 1, Constraints = "$rnd = $rns", isAdd = 1 in {
  def ADDrr : FNM<0x3, 0xC, (outs GPR:$rnd), (ins GPR:$rm, GPR:$rns),
                  "add $rm, $rnd",
                  [ (set i32:$rnd, (add i32:$rm, i32:$rns)) ]>;
```

---

class: middle, center, inverse

### What is actually generated

##### J2GenAsmMatcher.inc - AsmParser

```c++
static const MatchEntry MatchTable0[] = {
  { 0 /*add*/, J2::ADDrr, Convert_Reg1_1_Reg1_0_Tie0, 0, { MCK_GPR, MCK_GPR }, },
```

##### J2GenAsmWriter.inc - AsmPrinter

```c++
case 2:
  // ADDrr
  printOperand(MI, 1, O);
  O << ", ";
  printOperand(MI, 0, O);
  return;
  break;
```

---

class: middle, center, inverse

### What is actually generated

##### J2GenDisassemblerTables.inc - Disassembler

```c++
static const uint8_t DecoderTable16[] = {
  /* 221 */     MCD::OPC_Decode, 83, 4, // Opcode: ADDrr
```

##### J2GenMCCodeEmitter.inc - Assembler

```c++
case J2::ADDrr:
  // op: src
  op = getMachineOpValue(MI, MI.getOperand(0), Fixups, STI);
  Value |= (op & UINT64_C(15)) << 4;
  // op: dst
  op = getMachineOpValue(MI, MI.getOperand(1), Fixups, STI);
  Value |= (op & UINT64_C(15)) << 8;
  break;
```

---

class: middle, center, inverse

### What is actually generated

##### J2GenDAGISel.inc - Instruction selection

```c++
static const unsigned char MatcherTable[] = {
/*670*/         OPC_MorphNodeTo1, TARGET_VAL(J2::ADDrr), 0,
                    MVT::i32, 2/*#Ops*/, 0, 1,
                // Src: (add:i32 i32:i32:$rm, i32:i32:$rns) - Complexity = 3
                // Dst: (ADDrr:i32 i32:i32:$rm, i32:i32:$rns)
/*678*/       0, /*End of Scope*/
```

##### J2GenInstrInfo.inc - Instruction information

```c++
namespace J2 {
  enum {
    ANDrr = 83,
```

```c++
  { 83, 3,  1,  2,  0,  0|(1ULL<<MCID::Add)|(1ULL<<MCID::Commutable), 0x0ULL,
    nullptr, nullptr, OperandInfo22, -1 ,nullptr },  // Inst #83 = ADDrr
```

---

class: middle, center, inverse

# Code generation

---

class: top, center, inverse

# Code generation

### Calling convention lowering

```tablegen
def CC_J2 : CallingConv<[
  CCIfType<[ i1, i8, i16 ], CCPromoteToType<i32>>,
  CCIfType<[ i32 ], CCAssignToReg<[ R4, R5, R6, R7 ]>>,
  CCIfType<[ i32 ], CCAssignToStack<4, 4>> // 4 bytes size, 4 bytes alignment.
+]>;
```

--

#### Ask calling convention what to do

#### Generate target-specific instructions

#### J2-specific: move arguments to registers

---

class: top, center, inverse

# Code generation

### Legalization

--

```llvm
%bool = cmp slt r1, r2
```
```asm
cmp/ge r2, r1
```

--
|
```llvm
%sh = shl r1, 20
```
```asm
shll16 r1
shll2 r1
shll2 r1
```

--

```c++
setOperationAction(SHL, i32, Custom);
```

Then lower manually.

---

class: top, center, inverse

# Code generation

### Legalization

Legal

* Supported by the target.

--

Libcall

* Call the runtime.

--

Promote

* Promote the type to a larger type.

--

Expand

* Expand to other opereations, if possible.

---

class: top, center, inverse

# Code generation

### Instruction Selection

##### IR -> DAG

#### Convert IR to a graph (DAG)

--

##### BB -> MBB

#### Select one basic block at a time

--

##### Select()

#### Generic algorithm, based on the generated files from every target

--

##### Custom

#### But some manual work needs to be done

---

class: top, center, inverse

# Code generation

### Instruction Selection

##### Addressing modes

--

```c
int tab[30];
int a = tab[2];
```

--

J2

```asm
mov.l @Rm, Rn                           -                   (Rm) -> Rn
mov.l @(R0, Rm), Rn                     -                   (R0 + Rm) -> Rn
mov.l @(disp, Rm), Rn                   -                   (Rm + disp * 4) -> Rn
```

Select the correct addressing mode.

```asm
mov.l @(2, r14), r1
```

---

class: top, center, inverse

# Code generation

### Frame lowering

--

class: top, center, inverse

##### Prologue / Epilogue

```asm
mov.l r14, @r15			 ; push $fp
mov r15, r14				; $fp = $sp
add #-8, r15				; $sp -= 8
[...]
mov r14, r15				; $sp = $fp
mov.l @14, r14			  ; pop $fp
rts						 ; return
```

##### Callee save / regalloc spilling

* storeRegToStackSlot

* loadRegFromStackSlot

---

class: top, center, inverse

# Code generation

### Relocations

#### Generate relocations for unknown symbols

```tablegen
def BSR : FD12<0xB, (outs), (ins j2CallTarget:$target),
               "bsr $target",
               [ (call tglobaladdr:$target) ]>;
```

--

##### Add fixups to the final object file

```c++
Offset = 0;
MCFixup::create(Offset, MO.getExpr(), J2::fixup_J2_BSR, MI.getLoc());
```
